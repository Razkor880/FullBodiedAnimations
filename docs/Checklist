This checklist is the source of truth for the Full Bodied Animation mod architecture and implementation plan.

Goals:
Build a clean, future-proof SKSE plugin that applies transforms, morphs, FX, and gameplay state changes driven by animation timing.
Support both INI-based timelines and HKX annotation timelines.
Support paired animations (caster / target) with strict role separation.
Avoid recreating or copying legacy mods; prior working code is reference only.
Prefer minimal systems with clear responsibilities and a single source of truth.

Rules:
No feature is considered complete until explicitly confirmed.
Systems are provisional until proven stable, then become canon.
Do not introduce new timing systems unless required.
Do not duplicate logic across modules.

END OF ASSIGNMENT DESCRIPTION

PHASE 0 – BOOTSTRAP (COMPLETE)

Goal: Confirm a working CommonLibSSE-NG plugin with logging and Papyrus communication.

[x] CommonLibSSE-NG “hello world” plugin builds and loads
[x] SKSEPluginLoad is wired correctly
[x] Logging is verified in the SKSE log directory
[x] Papyrus native registration works
[x] Papyrus to native call path verified in game

Exit condition:
The plugin loads, logs, and responds to a Papyrus call.

PHASE 1 – CORE BACKBONE (COMPLETE)

Goal: Establish the stable execution backbone.

Core Modules

[x] FBPlugin entry point, registration, lifetime owner
[x] FBConfig immutable snapshot loading and reload
[x] FBEvents event queue push and drain
[x] FBUpdate per-tick execution
[x] FBUpdatePump timing driver
[x] FBStructs shared data types (Generation, FBCommand, TweenSpec, etc.)

Proven Behaviors

[x] Events can be queued and drained
[x] Update pump ticks continuously
[x] Commands execute on valid 3D actors
[x] Generation swap on config reload works

Exit condition:
A test FB event successfully flows through the system and reaches execution.

PHASE 2 – TIMELINES AND SCRIPTING (IN PROGRESS)
(aka “Phase 1.5 — Script Timelines” in assignment notes)

Goal: Introduce author-driven timelines without changing the execution backbone.

Timeline Data Model (DATA SHAPES ONLY)
[x] TimedCommand defined as time plus FBCommand
[x] FBCommand remains execution-level with no timing data
[x] Snapshot contains an eventMap-like concept (event tag -> script key)
[x] Snapshot contains a scripts-like concept (script key -> TimedCommand list)

Reality note:

Snapshot/eventMap/scripts currently exist and are usable, but are filled via hardcoded test data (not INI yet).

FBUpdate currently does not schedule; it executes all commands immediately.

INI Parsing (NOT IMPLEMENTED YET)
File layout rules
[ ] One global FullBodiedIni.ini in the mod root for debug and global settings
[ ] One FB_.ini per animation
[ ] Per-animation INI lives in the same folder as its HKX
[ ] Open Animation Replacer variant folders are supported
[ ] Multiple HKX files can exist in a variants folder
[ ] Each HKX has its own corresponding FB_*.ini
[ ] Hardcoded root path supported as an initial milestone (before auto-discovery)

INI command rules (NOT IMPLEMENTED YET)
[ ] Sections identify animation and role (Caster or Target)
[ ] Each command line begins with a timestamp
[ ] Commands without a prefix target the Caster
[ ] Commands prefixed with 2_ target the Target
[ ] Parsing produces FBCommand objects only (no timing logic in FBCommand)
[ ] No execution occurs during parsing

Node Mapping (PARTIAL)
[x] Stable author-facing node keys exist somewhere in-code (current node library)
[ ] Node mapper lives in a neutral shared location (FBStructs or FBTransform)
[ ] Existing node lists from the old project are used as reference only
[ ] Node mapping reused by Transform and Morph systems (single source of truth)

Timeline Execution (NOT IMPLEMENTED YET)
[ ] Track elapsed time since animation start (per active timeline instance)
[ ] Execute TimedCommands when their timestamp is reached
[ ] Ensure commands execute only once
[ ] Support multiple overlapping timelines (at minimum: multiple actors)
[ ] Support paired roles (Caster and Target) as separate timelines
[ ] Keep execution logic entirely inside FBUpdate
[ ] FBConfig does parsing only; FBUpdate does execution only (no text parsing in tick)

CURRENT CODE REALITY CHECK (helps avoid regressions)
[x] A test FB event can flow through the system and reach execution
[x] Commands can execute on valid 3D actors
[x] Scale operations can be executed as a command (known-working executor path)
[ ] Timeline scheduling based on time does NOT exist yet (everything fires immediately)
[ ] INI parsing does NOT exist yet (hardcoded Snapshot content only)

Exit condition:
INI-defined timelines execute at the correct times during animation playback (with correct role targeting), without changing the existing backbone modules.

PHASE 3 – FBTRANSFORM BUILD-OUT (PLANNED)

Goal: Fully implement transform operations for animation-driven body manipulation.

[x] FBTransform module exists and is wired into execution
[x] Scale operations work visually in game

Remaining work

[ ] Support node translation (local position)
[ ] Support node rotation (local rotation)
[ ] Support combined transform operations (scale + rotate + move)
[ ] Support any valid skeleton NiNode as a target
[ ] Ensure transforms respect actor 1P / 3P state correctly
[ ] Keep FBTransform stateless; no timing or tween logic inside

Exit condition:
FBTransform can apply location, rotation, and scale to any specified node at runtime.

PHASE 4 – FBMORPH BUILD-OUT (PLANNED)

Goal: Fully implement morph and expression support.

[x] FBMorph module exists as a stub

Remaining work

[ ] Support arbitrary RaceMenu slider morphs by name
[ ] Support multiple simultaneous morphs
[ ] Support facial expressions (phonemes, expressions, or equivalent)
[ ] Support target selection (Caster / Target)
[ ] Ensure morph application is reversible
[ ] Keep FBMorph stateless; no timing or tween logic inside

Exit condition:
FBMorph can drive any RaceMenu morph or expression via timeline commands.

PHASE 5 – HKX AND ANNOTATION INTEGRATION (PLANNED)

Goal: Drive timelines from HKX annotations instead of INI files.

[ ] Detect animation start events for paired and solo animations
[ ] Read annotation timestamps from HKX files
[ ] Convert annotations into TimedCommands
[ ] Reuse the same execution pipeline as INI timelines
[ ] Avoid duplicating execution logic

Exit condition:
INI timelines and HKX annotations produce identical runtime behavior.

PHASE 6 – TWEENING AND EASING (PLANNED)

Goal: Smooth transitions with predictable behavior.

[ ] Tween data stored separately from execution
[ ] Linear easing used by default
[ ] Easing types optional and extensible
[ ] FBUpdate owns interpolation state
[ ] FBTransform and FBMorph remain stateless executors

PHASE 7 – GAMEPLAY STATE EFFECTS (PLANNED)

Goal: Safe gameplay changes tied to animations.

[ ] FBState executes gameplay changes
[ ] No Papyrus required at runtime
[ ] State effects automatically revert when timelines end

PHASE 8 – TOOLING AND OAR UI (FUTURE)

[ ] Runtime reload without restarting the game
[ ] Open Animation Replacer UI integration
[ ] Live timeline inspection and debugging

CANON NOTES

FBUpdate Tick never parses text and only executes commands.
FBConfig is the only place where INI or annotation parsing occurs.
FBUpdate never mutates configuration data.
Requeue logic is optional and currently disabled.
Caster and Target are the only supported roles.
