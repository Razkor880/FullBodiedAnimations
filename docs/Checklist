This checklist is the source of truth for the Full Bodied Animation mod architecture and implementation plan.

Goals:
Build a clean, future-proof SKSE plugin that applies transforms, morphs, FX, and gameplay state changes driven by animation timing.
Support both INI-based timelines and HKX annotation timelines.
Support paired animations (caster / target) with strict role separation.
Avoid recreating or copying legacy mods; prior working code is reference only.
Prefer minimal systems with clear responsibilities and a single source of truth.

Rules:
No feature is considered complete until explicitly confirmed.
Systems are provisional until proven stable, then become canon.
Do not introduce new timing systems unless required.
Do not duplicate logic across modules.

END OF ASSIGNMENT DESCRIPTION

PHASE 0 – BOOTSTRAP (COMPLETE)

Goal: Confirm a working CommonLibSSE-NG plugin with logging and Papyrus communication.

[x] CommonLibSSE-NG “hello world” plugin builds and loads
[x] SKSEPluginLoad is wired correctly
[x] Logging is verified in the SKSE log directory
[x] Papyrus native registration works
[x] Papyrus to native call path verified in game

Exit condition:
The plugin loads, logs, and responds to a Papyrus call.

PHASE 1 – CORE BACKBONE (COMPLETE)

Goal: Establish the stable execution backbone.

Core Modules

[x] FBPlugin entry point, registration, lifetime owner
[x] FBConfig immutable snapshot loading and reload
[x] FBEvents event queue push and drain
[x] FBUpdate per-tick execution
[x] FBUpdatePump timing driver
[x] FBTransform NiNode scale and transform application
[x] FBMorph Racemenu slider and expression interface (stub acceptable)
[x] FBFx FX placeholder (stub acceptable)
[x] FBState gameplay state placeholder (stub acceptable)
[x] FBStructs shared data types (Generation, FBCommand, TweenSpec, etc.)

Proven Behaviors

[x] Events can be queued and drained
[x] Update pump ticks continuously
[x] Commands execute on valid 3D actors
[x] Transform scaling visibly works in game
[x] Generation swap on config reload works

Exit condition:
A test FB event causes a visible head scale in game.

PHASE 1.5 – TIMELINES AND SCRIPTING (IN PROGRESS)

Goal: Introduce author-driven timelines without changing the execution backbone.

Timeline Data Model

[x] TimedCommand defined as time plus FBCommand
[x] FBCommand remains execution-level with no timing data
[x] Snapshot stores eventMap mapping event tags to script keys
[x] Snapshot stores scripts mapping script keys to TimedCommand lists

INI Parsing

File layout rules

[x] One global FullBodiedIni.ini in the mod root for debug and global settings
[x] One FB_<hkxname>.ini per animation
[x] Per-animation INI lives in the same folder as its HKX
[x] Open Animation Replacer variant folders are supported
[x] Multiple HKX files can exist in a variants<baseclip> folder
[x] Each HKX has its own corresponding FB_*.ini

INI command rules

[ ] Sections identify animation and role (Caster or Target)
[ ] Each command line begins with a timestamp
[ ] Commands without a prefix target the Caster
[ ] Commands prefixed with 2_ target the Target
[ ] Parsing produces FBCommand objects only
[ ] No execution occurs during parsing

Node Mapping

[x] Stable author-facing node keys are defined (Head, Spine1, LUpperArm, etc.)
[ ] Node mapper moved to a neutral location such as FBTransform or FBStructs
[ ] Node mapping reused by Transform and Morph systems

Timeline Execution

[ ] Track elapsed time since animation start
[ ] Execute TimedCommands when their timestamp is reached
[ ] Ensure commands execute only once
[ ] Support multiple overlapping timelines for caster and target
[ ] Keep execution logic entirely inside FBUpdate

Exit condition:
INI-defined timelines execute at the correct times during animation playback.

PHASE 2 – HKX AND ANNOTATION INTEGRATION (PLANNED)

Goal: Drive timelines from HKX annotations instead of INI files.

[ ] Detect animation start events for paired and solo animations
[ ] Read annotation timestamps from HKX files
[ ] Convert annotations into TimedCommands
[ ] Reuse the same execution pipeline as INI timelines
[ ] Avoid duplicating execution logic

Exit condition:
INI timelines and HKX annotations produce identical runtime behavior.

PHASE 3 – TWEENING AND EASING (PLANNED)

Goal: Smooth transitions with predictable behavior.

[ ] Tween data stored separately from execution
[ ] Linear easing used by default
[ ] Easing types optional and extensible
[ ] FBUpdate owns interpolation state
[ ] FBTransform and FBMorph remain stateless executors

PHASE 4 – GAMEPLAY STATE EFFECTS (PLANNED)

Goal: Safe gameplay changes tied to animations.

[ ] FBState executes gameplay changes
[ ] No Papyrus required at runtime
[ ] State effects automatically revert when timelines end

PHASE 5 – TOOLING AND OAR UI (FUTURE)

[ ] Runtime reload without restarting the game
[ ] Open Animation Replacer UI integration
[ ] Live timeline inspection and debugging

CANON NOTES

FBUpdate Tick never parses text and only executes commands.
FBConfig is the only place where INI or annotation parsing occurs.
FBUpdate never mutates configuration data.
Requeue logic is optional and currently disabled.
Caster and Target are the only supported roles.
