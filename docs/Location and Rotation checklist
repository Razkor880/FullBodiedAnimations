DESCRIPTION

This project implements a stateless animation-driven transform and morph system for Skyrim actors. All timing, sequencing, and reset logic is owned by the timeline/update layer; transform and morph modules are pure executors that apply changes immediately on the game thread.

There are two major effect systems:

FBTransform
FBTransform applies local NiNode transforms (scale, and soon translation and rotation) to any resolved skeleton node. It does not store state, perform tweening, or manage timing. It is only responsible for safely finding nodes on the correct actor model and applying local transforms.

FBMorph
FBMorph applies RaceMenu/NiOverride body morphs and facial expressions via a minimal Papyrus bridge. Morph lifetime, sustain, and reset behavior is managed entirely in C++. Papyrus is a thin execution bridge only.

The execution flow is:

Animation events enqueue FBEvents

FBUpdate drains events, advances timelines, and fires FBCommands at the correct timestamps

FBExec parses FBCommand and dispatches to FBTransform or FBMorph

FBTransform / FBMorph apply changes immediately on the main thread

FBUpdate tracks original values and schedules reset (including optional delay)

Node and morph name mapping is centralized in FBMaps. If a name is not mapped, it is passed through verbatim.

All code must preserve:

Stateless executors (no timing logic inside FBTransform or FBMorph)

No world-space math (local transforms only)

No hidden caches or persistent state outside ActiveTimeline

Minimal Papyrus logic

The checklist below is the source of truth.

END OF DESCRIPTION

CHECKLIST

Phase 1 – Understand existing architecture

Read FBUpdate.cpp to understand timeline execution, reset scheduling, and delayed reset

Read FBExec.cpp to see how FBCommand is parsed and dispatched

Read FBTransform.cpp to see how scale is applied and how nodes are resolved

Read FBMorph.cpp and FBMorphBridge.psc to understand how morphs are dispatched through Papyrus

Confirm FBMaps.cpp is the only place that maps friendly names to real node or morph names

Phase 2 – FBTransform: translation support

Add a new Transform opcode (e.g. Move or Translate) handled in FBExec

Parse three floats from args (x, y, z)

Add ApplyTranslate_MainThread in FBTransform

Apply translation via obj->local.translate only (no world transforms)

Use the same node resolution logic as scale

Log failures once per unknown node

Phase 3 – FBTransform: rotation support

Add a new Transform opcode Rotate handled in FBExec

Accept Euler angles in degrees from INI

Convert degrees to radians internally

Apply rotation as a local transform only

Follow engine rotation representation (matrix or equivalent); do not invent math types

Keep rotation logic isolated and deterministic

Phase 4 – Combined transform behavior

Do NOT add a “set all transforms” call

Combined transforms are achieved by multiple commands at the same timestamp

Ensure ordering does not matter since transforms are absolute, not relative

Phase 5 – Node targeting and mapping

All node names flow through FBMaps::ResolveNode

FBMaps must remain pass-through by default

Any new aliases or friendly names must be added only in FBMaps

Unknown nodes should log once and then be suppressed

Phase 6 – 1P / 3P correctness

Default to applying transforms on the 3P model root

For the player, attempt to also apply to 1P model if the node exists

Do not duplicate logic; use a helper that tries both roots safely

Non-player actors must never attempt 1P logic

Phase 7 – FBMorph system constraints (do not break)

Morphs are applied via NiOverride.SetBodyMorph using a consistent key

Fake NiOverride.psc must match real RaceMenu signatures exactly (ObjectReference, not Actor)

Papyrus bridge must not contain reset logic or persistence

Morph sustain is handled by C++ timeline execution, not Papyrus

Reset clears only morphs touched by the timeline

Phase 8 – Safety and logging

All executor calls must guard against null actors and unloaded 3D

All transform/morph calls must log intent at info level and failures at warn level

No executor should crash if a node or morph does not exist

Phase 9 – Things explicitly not to do

Do not add timing, tweening, or easing logic to FBTransform or FBMorph

Do not add world-space math

Do not add hidden caches or persistent state

Do not move mapping logic out of FBMaps

Do not expand Papyrus beyond thin execution stubs
